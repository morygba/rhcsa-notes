Home
ip @: 192.168.0.40
Gateway: 192.168.0.1
DNS: 75.76.160.1,75.76.160.2

Laptop Assigned IP from Phone connection
ip @: 172.20.10.7
Gateway: 172.20.10.1
DNS: 172.20.10.1

Add new network interface thru vm setting 

nmcli device show
nmcli device status
nmcli device connect ens224
nmcli device status 

ifdown ens224
ifup ens224

systemcli restart NetworkManager



===========
SOFT LINK
Symbolic Link use to create a shortcut for files and directories
- cross file systems (file located in /boot but with a shortcut in /run)
- if soft link deleted, original file still exist
- if original file deleted, link is useless
- can be identify by -l 

ln -s orginal_file link_file 


HARD LINK
create 2 versions of the same file.
- Can only be used for files
- cannot cross file system
- if orginal file deleted, the link still exist
- if link deleted, original file still active
- hard link and original file have the same timestamp, inode, size

ln orignal_file link_file 


==================================
METACHARACTERS

!<number>   == re-execute the cmd number is history output
!45

!! == re-execute the last command 

* == match 

? == match exact character 

; == concatinate commands 



=============================================
COMPRESSION TOOLS 
zip, unzip
zip filename.zip <file_to_compress>
zip -r dirname.zip <dir_to_compress>
uncompress
unzip filename.zip
unzip filename.zip -d /tmp    to uncompress it to a different directory
unzip -r dirname.zip

gzip,gunzip
gzip <file.gz> 
gzip -r <dir_to_compress>
gunzip file.gz
gunzip dir_to_unzip
gunzip filename.zip -d /tmp

bzip2,bunzip2
bzip2 file_to_compress
bunzip2 file.bz2

tar = create archive = tarball
Putting multiple files into one. Don't compress, just create the tarball
tar cvf <tarball.tar> <file/dir_to_archive>
c:create
v:verbose
f:specify .tar file names
list the content of the tarball
tar tvf <tarball.tar>
t:list the content
untar
tar xvf <tarball.tar>
tar xvt <tarball.tar> -C <dest_location> 
x:extract it
-C:location to untar

Create a tarball and compress it
tar cvfz (gzip)
tar cvfz <tarball.tar.gz>  <file/dir_to_archive>
tar cvfj (bzip2)
tar cvfj <tarball.tar.bz2>  <file/dir_to_archive>

Uncompress 
tar xvfz (gunzip)
tar xvfz <tarball.tar.gz>  <file/dir_to_archive>
tar xvfj (bunzip2)
tar xvfz <tarball.tar.gz>  <file/dir_to_archive>


awk 
ll -h | awk {'print $9 "   " $5}
Field deliminator or seperator 
cat  /etc/passwd | awk -F ":" {'print $1'} 

cut
cut -d == awk -F
cut -d ":" -f 1,2 /etc/passwd
cat /etc/passwd | cut -d ":" -f 1,2

=============================================
sed
sed 's/old-word/new-word/g' <file-name>
sed -i 's/old-word/new-word/g' <file-name>  
-i:permanently replace the word 
sed 's/old-word/new-word/2' <file-name> -->replace the 2nd occurence
sed '3 s/old-word/new-word/' <file-name> -->replace at a specific line.
sed '3,$ s/old-word/new-word/' <file-name> -->replace from a specific line till the end of the text

sort
sort -r   -->reverse
sort -n   -->numerically
sort -rn  -->reverse number
sort -k 2n -->sort at a specific column number

uniq
uniq -c  -->count the duplicate

cat training.log | awk {'print $1'} | sort -n | uniq -c | sort -rn | head -n 5

& ampersand = and -->run a command in the background

fg %2  -->bring job number 2 to the foreground

jobs  -->to see all jobs

ctrl+z  -->stop the job

bg  -->to send a command in the background
 
=========================================================
Local users and groups managment
4 type of users
1- system users: user ID 1-999 rhel7/8 
                 user ID 1-499 rhel6  
2- regular users: user ID 1000-60000 rhel7/8
                  user ID 500-60000 rhel6   
3- network users: LDAP/FreeIPA/AD users
4- root user: user ID 0 always
/etc/passwd == contain all local users info 
/etc/shadow == contain all local users password 
/etc/group == contain all local group info
/etc/gshadow == contain all local groups password

cat /etc/passwd
moryba:x:1000:1000:moryba:/home/moryba:/bin/bash
moryba = username
x = password saved in /etc/shadow
1000 = user ID (UID)
1000 = group ID (GID)
moryba = comment
/home/moryba = home directory
/bin/bash = shell   (cat /etc/shells) 

cat /etc/shadow
moryba:$6$WYouyqPYAWjEeTAb$N6cpZAGc4GY7JG55zzED86KJVQtwxs.iMvbNAKT2aa6c
WhPsrjixRzv.Q8nkUQc.gpttS72.DeTeonShOoBGP.::0:99999:7:::
moryba = username
$6$WYouyqPYAWjEeTAb$N6cpZAGc4GY7JG55zzED86KJVQtwxs.iMvbNAKT2aa6cWhPsrji
xRzv.Q8nkUQc.gpttS72.DeTeonShOoBGP. = encrypted password
:: = last time the password was last modified (date - epoch time) 
     epoch time = 1/1/1970 
0 = minimum days to wait in order to change password 
99999 = maximum days to wait in order to change password 
7 = warning days
: = inactive days
: = disable days 
: =

cat /etc/group            
moryba:x:1000:
moryba = groupname 
x = passwd saved in /etc/shadow
1000 = GID
: = all users that belong to this group
grep wheel /etc/group
wheel:x:10:papa,admin,king

cat /etc/gshadow
moryba:!::
moryba = groupname
! = encrypted password (! meaning no encrypted password)
:  = group admin
:  = group members 


#create lacal user
useradd
useradd <username>
id <username>  -->to verify 
tail -1 /etc/passwd 
-u = UID
-g = GID
-m = create a home directory
-d = specify the home directory location
-s = specify the shell 
      cat /etc/shells 
-k = copy everything in /etc/skel to the user home directory 
      ll -a /etc/skel
-c = comment 
useradd -u 5000 -g 5000 -m -d /home/user1 -k /etc/skel -s /bin/bash user1

#create a password for user
passwd <username>
grep <username> /etc/shadow -->to verify
tail -1 /etc/shadow

#switch user
+su -   -->to become root
exit
logout
ctrl+D 
su - <username> -->to switch to another user account

===========================================================
usermod   -->change information. Uses the same options as useradd

#change user name 
usermod -l newusername oldusername 

#set expiration date
-e = set the experation date
usermod -e YYYY-MM-DD <username>
grep <username> /etc/shadow --> to verify
chage -l <username>  -->user account expiration

#lock account
usermod -L <username> 
passwd -l <username>
 usermod -L user1

tail -f /var/log/secure -->follow the log live 
grep <username> /var/log/secure 

#unlock account
passwd -u <username>

passwd -n -x -w username
chage -m 'min-day' -M 'Max-day'-W Warning-day' -E YYYU-MM-DD <username>
chage -l <username>  -->to verify all these info  

chage -m 8 -M 20 -W 10 -E 2022-08-02 user1
chage -l user1   -->to verify

#interactive mode
chage <username>

#add new user process
userdd username
passwd username
chage -d 0 username -->force user to change the passwd at next login

for i in user1 user2 user3; do useradd $i; echo "123456" | passwd
$i --stdin; done

#delete user
/var/spool/mail -->all users mailbox location
/home           -->all users home directory location by default
userdel
userdel -r <username>  -->delete the user, its mailbox and its home dir 

#create a group 
groupadd <groupname>
groupadd -g <groupID> <groupname> 
groupadd -g 3005 finance 

#modify group
groupmod 
groupmod -n mewname oldname
groupmod -n finan finance 
groupmod -g 4005 finan  -->to chance the group ID 

#delete goup
groupdel <groupname>
groupdel finan


#add user to a group
gpasswd 
gpasswd -a <username> <groupname> 
groups username -->to see all groups that the user belongs to
id username -->to verify

usermod 
usermod -a -G <groupname> <username>

for i in user1 user2 user3; do useradd $i; echo "123456" | passwd
$i --stdin; done

=================================================================
#temporary change the user primary group
newgrp 
newgrp <newgroupname>   -->
create devops group
groupadd devops
add user3 to devops group


su - <username>  -->to switch to a different user

#grant root privileges to user
visudo = open /etc/sudoers file = vim /etc/sudoers
yy p
 


#to run a command as root
sudo <command>

#to become root
su -
sudo -i 

visudo
search for wheel

#add user to wheel group
gpasswd -a <usnername> wheel
su - username 
sudo -i 

==============================================================
permissions
3 types of permissions 
			file			directory
- read r 	4	see content		list content
- write w 	2	modify			create file/directory
- execute x	1	run as script		cd to the directory

#change/set permission
chmod ### filename 
chmod 666 testfile  

#symbolic notation
rw-rw-r--
u  g  o
chmod u=rwx filename
chmod u+x filename

chmod u-w filename

chmod g+x filenane 
chmod g-x filename

chmod o+x filename 
chmod o-x filename

chmod ug+x filename 
chmod ug-x filename 

chmod a+x filename   -->a for all (everyone)
chmod a-x filename  
chmod -x filename  -->a NOT SPECIFIED means all
chmod +x filename 

chmod -R <dirname>  -->change perm in dir recursively

regular user
umask
0002
file	0664	0666
dir 	0775	0777

root user
umask
0022
file	644  
dir	755

umask -S -->get the perm is symbolic notation

=======================================================================
#change owner and group
chown
chown <newownwer> file/dirname
chown -R <newowner> dirname  -->recursive change

chown <newowner>:<newgroup> file/directory
chown -R <newowner>:<newgroup> directory 

chown  :<newgroup> file/dir -->change group only
chown -R:<newgroup> directory

#change group
chgrp
chgrp <newgroup> file/directory
chown :<newgroup> file/directory

chgrp -R <newgroup> directory 
chown -R :<newgroup> directory

#setuid (4)
rws    -->s 
r-x
r-x
find / -perm -4000  -->list all command that can be run by root only.

octal notation
chmod 4755 <filename>  
4 is to add setUID  
0 to remove setUID

symbolic notation
chmod u+s <filename>   -->to add setUID
chmod u-s <filename>   -->to remove setUID

chmod u-s /bin/wall
chmod 0755 /bin/wall
chmod u+s /bin/wall 
chmod 4755 /bin/wall


#group collaboration (setgid) 2
octal notation
chmod 2070 <dirname>
chown nobody:<grouname> <dirname?
chmod 0070 <dirname>  -->removes group collabortion

symbolic notation
chmod g+s <dirname>
chmod nobody:<groupname> <dirname>
chmod g-s <dirname>   -->removes group collaboration  

#sticky bit (1)
- only owner can delete a file in group collabration. 
- only set it on the group collaboration directory  
octal notation 
chmod 1070 <dirname>  -->to activate
chmod 0070 <dirname>  -->to remove

symbolic notation
chmod o+t dirname  -->to activate
chmod o-t dirname   -->to remove

#All directories with group collaboration set
find / -type d -perm -2000 

#All directories group with stick bit set 
find / -type d -perm 1000

#All directories with both group collaboration and sticky bit set
find / -type d -perm -3000


#attributes
lsattr <filename>  -->to display file attribute
chattr <filename>  -->to change file attribute

i : file can't be modify/remove or immutable even by root
 
chattr +i <filename>
chattr -i <filename>

#################################################################
processes
It's any program, application or command running on the system.
PID: process ID
Time: time
cmd: command
tty: terminal 
UID: user that started the program

4 process states
running = process currently working
sleeping = waiting for a input
stopped = process no longer  work
zombies = process is dead

#ps  -->list processes
ps -ef -->list all processes
UID : user ID
PID : prcoess ID
PPID : parent process ID
C : CPU utilization
STIME : Start time
TTY : terminal in which process is being executed from
TIME : the amount of time that the process has being running for.
CMD : the executed 
? : running in the bg and initiated by the system itself

ps -ef | grep bash | grep -v grep | wc -l 
ps -ef | grep [b]ash | wc -l 
To count the number of processes that are running in bash

ps -U <username>  -->to see the list of all programs a particular user
                     is running,

#top
see system utilization in realtime 

#pidof
see to a command process ID
pidof <program/command>  -->to see a cmd/prg ID

#pgrep
same as pidof
pgrep <program/command>  -->to see a cmd/prg ID

#kill
kill <processID>
kill $(pidof processname)
kill 

#kill -l  -->list of signals 
15)  terminate yourself nicely/politely
9)
kill -9 <processID>
kill -15 <processID>

#killall  -->to kill program with many processIDs
killall <program-name>
killall -u <username> -->to kill all processes ran by the user
passwd -l <usernname> -->lock user account

#pkill
pkill <process-name>

##################################################################
process niceness = process priority 
-20  to 19
-20 is the higest priority
19 is the lowest priority

default niceness level is 0

ps -efl -->list niceness level 

#nice
nice -n -20 top 
ps -efl | grep <program-name>  -->display the prg/cmd niceness level

renice -n 5 PID  -->to renice a running process 


#job scheduling (at,cronjob)
at
use to schedule a one time task
at now + 1 hour 
enter
ls /home 
ctrl+D 

#To see all schedule future jobs 
at -l
atq
ll /var/spool/at

#delete a scheduled job
atq (at -l)

at -d <job-ID>
atrm <job-ID>

#display a job content
atq 
at -c <jobID>

#deny permission to user to schedule a job
at.deny
vim  /etc/at.deny
<insert users to deny>

#deny at job to 5000 users at allow only 2 users
1. delete at.deny
2. create at.allow
3. vim /etc/at.allow
<inser allow users>

#cronjob use to schedule repited tasks 
cron.deny
cron.allow
Same concept as at command 

######################################################
cronjob or crontab

#schedule a job
crontab -e

#list all schedule job
crontab -l

#scehule a job for a specific user
crontab -u <username> -e 
crontab -u <username> -l  -->list jobs for that user

vim /etc/crontab
m h dom	m dow <cmd>
* *  *	*  *  command to be executed 
(0-59) (0-23) (1-31) (0-6)  

* 22 * * * ls /home >> /tmp/home.txt  -->every day at 10pm
*/5 * * * * ls /home >> /tmp?home.txt   -->every 5 min 
0 22 * * 7 ls /home/>> /tmp/home.txt -->every sunday at 10-m
0 22 * * 6,7 ls /home >> /tmp/home.txt -->every sat & Sun 
0 22 * * 5-7 ls /homr >> /tmp/home.txt -->Thur through Sun 
*/xx -->evey 

uptime to /tmp/uptime2.txt every 2mins, from 2am to 4am, the 12th 
and the 20th of the month, every 3 months, and on Thursday and 
Saturday

*/2 2-4 12,20 */3 4,6 uptime >> /tmp/uptime2.txt 

#recommend disabling a job instead of deleting it 
crontab - e
# (comment out line)
# (comment out line)

############chap5
packages management

rmp

yum  / dnf
      (rhel8)
- mount the cdrom/iso image 
- make sure the iso image is connected to the server 
- mount /dev/cdrom /mnt
- df -h or df -h /mnt

ls /mnt/BaseOS/Packages     -->rhel8 system packages
ls /mnt/AppStream/Packages  -->Third-party application packages

#rpm based Linux flavors
redhat
CentOS
fedora
scientific linux
oracle linux
amazon ami
amz1 rhel6
amz2 rhel7/8

zsh-5.5.1-6.el8_1.2.x86_64.rpm

zsh  -->package name
5.5.1 -->package version
6 -->package release
el8  --> redhat8 centos8 fedora22
x86_64 -->architecture  64bits
i868 -->architecture 32bits
rpm   --rpm package
noarch.rpm -->can be install on 64 or 32bit architecture

#install package
rpm -ivh <package_name>  -->to install the package
rpm -ivh /mnt/BaseOS/Packages/zsh----

#check if package is installed 
rpm -qa | grep <package_name>  -->verify 
rpm -qa | grep zsh

rpm -qa   -->list all installed packages
rpm -qa | wc -l

#upgrade package
rpm -Uvh <package_name>  -->upgrade or install package

#remove package 
rpm -e <package_name> 
rpm -ev <package_name> --verbosely 
rpm -qa | grep <package_name>  -->verify if package has been installed

Your coworker sent these 3 packages
1- which one of them you will install and why?
2- what are the steps you will take to install the correct package
zsh-5.5.1-6.el8.x86.rpm
zsh-5.5.1-6.el7.x86.rpm
zsh-5.5.1-6.el6.x86.rpm

1-check linux version 
  uname -r
  cat /etc/*release or cat/redhat-release
2-install the appropriete package
  rpm -ivh 

######################################################
yum / dnf

yum install <package>
dnf install <package>

what is a repository?
place holder for packages

cd/dvd repo
local repo
network repo: http/https, ftp

#create a cd/dvd/ repo
1- mount /dev/cdrom /mnt
2- create the yum client
   /etc/yum.repos.d 
   must end with .repo (local.repo)  
- cd /etc/yum.repos.d
- vim cd.repo
	[cdBaseOS]
	name=cd baseosrepo
	baseurl=file:///mnt/BaseOS
	enabled=1
	gpgcheck=0

	[cdAppStream]
	name=cd appstreamrepo
	baseurl=file:///mnt/AppStream
	enabled=1
	gpgcheck=0
check the package integrity : gpgcheck=0
3-yum clean all
4- yum repolist

################################################
#local repo
1- mount /dev/cdrom/ mnt
2- confirm 
   df -h
3- create directories 
mkdir /baseos
mkdir /appstreams
4- copy the rpm to the directories
cp /mnt/BaseOS/Packages/*.rpm baseos
cp /mnt/AppStream?Packages/*.rpm appstream
5- install packages with rpm command
rpm -ivh /mnt/BaseOS/Packages/createrepo_c0....rpm
Might need to install dependencies first
rpm -ivh /mnt/BaseOS/Packages/createrepo_c-libs (x86_64.rpm)
rpm -ivh /mnt/AppStream/Packages/createrepo_c-0...rpm
Might need to install dependencies first
rpm -ivh /mnt/AppStream/Packages/createrepo_c-libs (x86_64.rpm)

rpm -qa | grep createrepo
5- install packages with rpm command 
rpm -ivh /mnt/AppStream/Packages/drpm-0.4.1-1.el8.x86_64.rpm 
rpm -ivh /mnt/AppStream/Packages/createrepo_c-0.15.1-2.el8.x86_64.rpm
rpm -ivh /mnt/AppStream/Packages/createrepo_c-libs-0.15.1-2.el8.x86_64.rpm

6- run create repo command  
createrepo -v /appstream/
ll /appstream/repodata

create -v /baseos/
ll /baseos/repodata

7- create yum repo 
vim /etc/yum.repos.d/localappstream
[localappstream]
name=local appstream repo 
baseurl=file:///appstream
enabled=1
gpgcheck=0

vim /etc/yum.repos.d/localbaseos
[localbaseos]
name=local baseos repo 
baseurl=file:///baseos
enabled=1
gpgcheck=0

8- verify
yum clean all; yum repolist


#network repos file
http://repos8.linuxtechnologies.us/AppStream
http://repos8.linuxtechnologies.us/BaseOS

http://repos7.linuxtechnologies.us


create network repository (Project)

vim /etc/yum.repos.d/lt.repo
[ltbaseos]
name=lt base os
baseurl=https://repos8.linuxtechnolgies.us/BaseOS 
enabled=1
gpgcheck=0

[ltbappstream]
name=lt appstream os
baseurl=https://repos8.linuxtechnolgies.us/AppStream 
enabled=1
gpgcheck=0
###############################################################################
yum and dnf have the same syntax 
- /etc/yum.conf
- /etc/dnf/dnf.conf

#install packages 
yum install <packgae-name>
dnf install <package-name>

#list specific installed package  
yum list installed <packagename>
dnf list installed <packagename>
yum list installed | grep <packagename>
dnf list installed | grep <packagename>
rpm -qa | grep <packagename>

#list all install packages
yum list installed 
rpm -qa 

#list all packages in all repositories 
yum repoquery

#list all packages for a specific reposotory
yum repolist  -->list all repos
yum repoquery --repo <repoID>

#remove a package
yum remove <packagenae>
dnf remove <packagename>

############################################################
yum-config-manager
yum-config-manager --add-repo http://repo8.linuxtechnologies.us/BaseOS
yum-config-manager --add-repo http://repo8.linuxtechnologies.us/AppStream


yum-config-manager --add-repo /repo

yum install mysql --nogpgcheck

##############################################################
#Yum history 
yum history -->displays everything that have been remove, upgrade, 
               install on the server using yum 

/var/log/dnf.log    (rhel8)
/var/loog/yum.log   (rhel6/7)

#update packages
yum update <packagename>

#update Kernel
yum check-update | grep kernel   -->check for available kernel updates
uname -r         -->to check the current system kernel 
yum update kernel     -->update kernel
yum update kernel glibc  -->if you see 'glibc' in packages, a reboot is necessary
reboot server 
uname -r          -->to see the new kernel 

#update the OS/patching
yum check-update   -->check if OS upgrade package exist 
yum update         -->update the installed packages 

####################################################################
runlevel: define services that with run on your server
RHEL6                     	RHEL7/8
0 shutdown			poweroff.target		
1 single user mode 		rescue.target
2 multi user w/o network	multi-user.target
3 multi user w network		
4 not in used			not in used 
5 graphical			graphical.target
6 reboot			reboot.target

RHEL6
------
ll /etc/rc
cd /etc/rc3.d

#display run level
runlevel  -->displays the preview and current runlevel
N 5 
N: preview runlevel
5: current runlevel

#switch between runlevels temporarily
init <runlevel#>
init 3   -->switch to command mode
init 5   -->switch to graphical mode
inir 6   -->reboots the server
runlevel  -->to verify
5 3  
5: preview runlevel
3: current runlevel

#switch between runlevels permanently
/etc/inittab
vim /etc/inittab
id:3:initdefault    -->change 3 to 5 to modify the runlevel

reboot -f    -->to reboot the server and see if server with reboot on the specified runlevel
press ESC  -->to see what is happening in the background


RHEL7/8
------
ll /etc/rc
cd /etc/rc3.d

#display runlevel
systemctl get-default   -->displays to current runlevel
runlevel                -->also displays the preview and current runlevel
N 5 
N: preview runlevel
5: current runlevel

#switch between runlevels temporarily
init <runlevel#>
init 3
runlevel  -->to verify
5 3  
5: preview runlevel
3: current runlevel

systemctl isolate <newtarget>
systemctl isolate multi-user.target
systemctl isolate graphical.target

#switch between runlevels permanently
systemctl set-default <newtarget>
systemctl set-default graphical.target
systemctl get-default  -->display current runlevel 

rpm -qa | grep -i x11  -->to verify is graphical packages are installed

#############################################################
RHEL6
service  -->can be used in RHEL6/7/8
#start a service
service <servicename> start
#stop service
service <servicename> stop
#restart service
service <servicename> restart  -->required anytime service configurate changes. Not recommend in production
#reload service
service <servicename> reload   -->forces the system to used to the applied modification. Can be done when system is in production
#enable service
service <servicename> enable

chkconfg httpd on  -->telling the server to start this service anything after reboot
chkconfig --list   -->list all service  
chkconfig --list | grep httpd 
chkconfig httpd  --list  -->check service status. start everywhere is says on
chkconfig <service_name> off   -->disactivate the service
chkconfig <service_name> on    --> activate the service 
chkconfig <service_name> --level <level#> on  -->activate at a specific runlevel
chkconfig <service_name> --level <level#> off  -->disactivate at a specific runlevel
chkconfig httpd --level 35 on  -->activate at runlevel 3 and 5

Apache
/etc/httpd/conf/httpd.conf
vim /etc/httpd/conf/    -->virtual home configuration location
vim /etc/httpd/conf/httpd.conf

ll /var/run/httpd/

#firewall
cat /etc/services | grep -w http

IPTABLES  (default firewall for rhel6)
iptables -L  -->list all open ports 

/etc/sysconfig/iptables
option1 (config file modification)
1- vim /etc/sysconfig/iptables
vim /etc/sysconfig/iptables
2- copy and paste one line 
yyp  -->paste&paste list with port 22
3- change the port number 
change port 22 to 80
change ACCEPT to REJECT  -->block traffic on a specific port 
4- save changes
5- restart iptables
service iptables restart 
6- verify
iptables -L   -->to list all open ports
option2 (cli)
iptables -I INPUT -m tcp -p tcp --dport 443 -j ACCEPT   -->to accept
iptables -I INPUT -m tcp -p tcp --dport 443 -j REJECT   -->to reject  
A:append 
I:insert
service iptables save         -->to save changes 
service iptables restart      -->restart firewall
iptables -L                   -->verify 


RHEL7/8
/usr/lib/systemd/system/   -->services location
locate httpd.service      -->if no result is displayed 
yum install mlocate       -->install locate cmd
updatedb       -->update file database
locate httpd.service
you can see that httpd service is locate in /usr/lib/systemd/system
 
systemctl -->can only be used in RHEL7/8
#check service status 
systemctl status <servicename>
#start service
systemctl start <servicename> 
#stop service
systemctl stop <servicename>
#restart service
systemctl restart <servicename>
#reload service
systemctl reload <servicename>
#enable service
systemctl enable <servicename>
systemctl is-enabled <servicename>  -->will the service start if server reboots?
#disable service 
systemctl disable chronyd

systemctl status httpd -l 
-l: displays more info

#start and enable service 
systemctl enable --now <servicename>

FIREWALLD
#add service
1-firewall-cmd --permanent --add-service=<servicename>
2-firewall-cmd --reload 
firewall-cmd --permanent -add-service=httpd 
firewall-cmd --reload

#add service using port number
firewall-cmd --permanent --add-port=123/tcp
firewall-cmd --reload

#remove service 
1-firewall-cmd --permanent --remove-service=<servicename>
2-firewall-cmd --reload 
firewall-cmd --permanent -remove-service=httpd 
firewall-cmd --reload

#remove service using port number
firfirewall-cmd --permanent --remove-port=123/tcp
firewall-cmd --reload

#check all open ports
firewall-cmd --list-all     -->list all open ports and services 

##############################################################
#root password recovery in RHEL7/8
stop the grub
press e
add "init=/sysroot/bin/bash" in line linux16 after "quit"
ctrl+x
chroot /sysroot
mount -o remount,rw /  -->remount the system file by giving rw perm
passwd                -->to change the root passwprd
touch /.autorelabel   -->relable the file system 
exit
reboot 

#TUNED
TuneD  -->a program use to optimize the server performance.
          a.k.a fie tune a server 

yum install tuned
systemctl enable --now tuned 
systemctl status tuned 

#display all profile
tuned-adm list  

#display recommended profile 
tuned-adm recommend 

#change profile
tuned-adm profile <profilename>

#check active profile
tuned-adm active    -->displays current active profile 


#NTP (Network Protocol Time)

#install chrony  
yum install chrony
systemctl enable --now chronyd
systemctl status chronyd

#modify config file 
vim /etc/chrony.conf                vim /etc/ntp.conf  3.
yyp line start with pool
comment out 1st line 
make changes
server <ntpservername> iburst
ex: "server time.apple.com iburst"

systemctl restart chronyd    -->restart chrony service

#verify
chromyc tracking 
chronyc sources

############################################################
RHEL7/8
#NETWORK CONFIGURATION
/etc/sysconfig/network-scripts/
ls     --->display config files for network interfaces 

ip a     -->to display IP addresses
ifconfig -->to display IP @

#option 1
cd /etc/sysconfig/network-scripts/
vim ifcfg-ens130
   change IP
ifdown ens130   nmcli con down ens130   -->nmcli new cmd, if.. old cmd
ifup ens130     nmcli con up ens130 
ip a

#option 2 (graphical)
nmtui (Net manager Test User Interface)   or nmtui-edit
nmcli con down ens130
nmcli con up ens130
ip a  -->to verify changes

#option 3 (command line)
ip a
nmcli con modify <con-name> ipv4.addresses 192.168.0.50/24 
nmcli con down ens130
nmcli con up ens130
ip a
 		
#add a new network interface 
Manually add the new interface 
nmcli device status -->to check interfaces status 
nmcli device connect <new-NIC>  -->to activate the interface  
nmcli connection modify ens240 ipv4.addresses 192.168.1.155/24 ipv4.gateway 192.168.1.1 ipv4.dns 192.168.1.1 -->#assign IP/gateway/dns @
nmcli connection modify ens240 ipv4.method manual -->enable static connection

nmcli con down ens240
nmcli con up ens240
ip a 

###################################################################
SELINUX (Security Enhanced)

#selinux values
permission 
enforcing   -->gvmt 
disable     -->private compnies

config file: 
/etc/sysconfig/selinux 
vim /etc/sysconfig/selinux

#check status 
-option 1
cat /etc/sysconfig/selinux   -->check selinux mode
-option 2
getenforce 
-option 3
sestatus 

#change mode
-temporary
setenforce 0   -->permissive
setenforce 1   -->enforcing
-permanent
vim /etc/sysconfig/selinux
change SELINUX mode accordily
init 6    -->to reboot the server 

###################################################################
SSH (secure shell)

ssh terminal:
xshell
MobaXterm
putty
mputty

#syntax
ssh <server_ip>
ssh <hostname>  -->if fqdn setup
ssh <username>@<server_ip>
ssh -l <username> <server_ip>

web.linuxtechnologies.us
hostname=web
fqdn=web.linuxtechnologies.us

#ssh connection issue 
window key + r
cmd press ok
ipconfig /flushdns

#logout of ssh
ctrl + D   -->to logout from remote host
logout     -->to logout from remote host


#ssh secure log
ll /etc/log/secure

#config file 
/etc/ssh/sshd_config
vim /etc/ssh/sshd_config
permitRootLogin 
change yes to no   -->never allow root to remotely login
X11Forwarding 
change yes to no 
#Port 22       -->can be change to a different number 

systemctl restart sshd   -->necessary after any change in config file
firewall-cmd --permanent --add-port=newport/tcp
firewall-cmd --reload 
ssh -p newport username@remoteIP

#configure passwordless authentication
generate ssh keys 
ssh-keygen        -->command to run
id_rsa (private key)
id_rsa.pub (public)
/home/user/.ssh   -->location of keys 

ssh-keygen  -->to create ssh key
enter       -->to skip passphrase setting
enter
enter        -->to create a passwordless ssh connection

ll .ssh   -->displays the 2 keys 
ssh-copy-id -i .ssh/id_rsa.pub user@server-ip   -->exchange public key with any remote host we try to connect to

#############################################################
ACL
getfacl     -->list all acl
setfacl     -->use to give or remove access permission to a user to a file or directory
               w/o changing the original owner or group
syntax:
getfacl filename/dirname 

setfacl -m u:username:"octal-perm" filename/dirname
setfacl -m u:username:"symb-perm" filename/dirname
m: modify
setfacl -m g:groupname:"octal-perm" filename/dirname
setfacl -m u:groupname:"octal-perm" filename/dirname

to verify
-rw-rw----+ 1 root root 29 Jul 23 00:07 original.txt
check if the permission line has a (+) sign

#default acl
default acl can only be set on directories
setfacl -m d:u:username:"octal-perm" dirname
setfacl -m u:username:"perm" dirname  --> always set regular acl as well
setfacl -m d:u:username:"symb-perm" dirname
setfacl -m u:username:"perm" dirname  --always set regular acl as well
all files and dir on the folder will inherent the acl set on that directory 

#recursively set acl
alternative to default acl

syntax:
setfacl -R -m u:username:7 dirname
 
#remove acl 
syntax:
setfacl -x u:username filename/dirname  -->removes acl on file or dir

#remove default acl
setfacl -k dirname 

#homework
1- create user named acluser1; 123456 as pwd
2- create user named acluser2; 123456 as pwd
3- as user1 create a file called aclfile.txt
4. grant user2 rwx permissions to aclfile.txt
5. make sure user2 has access to aclfile.xt

1- useradd acluser1
   passwd acluser1   and enter pwd
2- useradd acluser2
   passwd acluser2   and enter pwd
3- su - acluser1
   touch aclfile
4- setfacl -m u:acluser2:7 aclfile.txt
   setfacl -m u:acluser2:x /home/acluser1  -->give access to home directory
5- vim /home/acluser1/aclfile.txt

###############################################################
partitions
a process of splitting/slicing the disk in multiple sections 
1- standard partitions (standard disk partitions) 
2- LVM (logical volume)  best innovation in Linux

2-types of partitions in linux:
data partition: /root, /tmp, /var, ....
swap partition: swap memory

I- Stardard Partition
RHEL6
df     -->disk free 
df -h

ll /dev/sd*     -->to check your disk naming convention

sda    -->1st disk
    sda1  -->1st partition
    sda2  -->2nd partition
    sda3
sdb    -->2nd disk
    sdb1
    sdb2
    sdb3
sdc    -->3rd disk
    sdc1
    sdc2
    sdc3
#number of pertitions
up to 3 primaries and 1 extended partition

#command to partition a disk
cfdisk     -->oldest
fdisk      -->most preferred 
parted     -->can't be reverted in case of a mistake 
gparted    -->

#check available disk space
cfdisk /dev/sda
parted /dev/sda print free

#In case there is no free space
physically add disk (in wmware settings)
*scsi
*single virtual disk 

ll /dev/sd*     -->to check your new disk disks
lsblk           -->to check your new disk

If disk is nor showing, run:
yum install sg3_utils    -->allow to see newly add disk w/o rebooting the server
rescan-scsi-bus -a       -->to rescan the disk
lsblk                    -->to display the newly added disk
fdisk -cu /dev/sdb       -->to slice the new disk
m   --to display all options (help)
p   -->print partition table
n   -->add new partition
p ->to add primary partitiion 
1  -->partition number (1st sector)
*Press Enter
*specify the size of this 1st partition
+K,M,G   (+1G)
Press Enter
p  -->to check if the partition has been created 
w  -->to save 
enter 
lsblk    -->to see the partition crearted on the new disk
partprobe /dev/sdb -->to force kernel to reread the partition table
REBOOT the sever if you still can't see the partition

#create the file system (how data is stored and retrieve on the disk)
xfs  RHEL7/8  up to 16TB
ext4 RHEL6    up to 1TB
ext3 RHEL5

mkfs.ext4 /dev/sdb1   -->create FS on top of the partition   (on the partiton, NOT the disk)

#create a space holder  (mount point)
mkdir /part1
mount -t ext4 /dev/sdb1 /part1  -->to mount the partition TEMPORARY
df - h     -->to verify

#make the mount permanent
/etc/fstab

/dev/sdb1	/part1	ext4	defaults	   0 0 
                                                order of scan. only root has 1 1. 0 0 means system don't check the partition
IF YOU MAKE A MISTAKE, SERVER WILL NOT BOOT UP.

mount -a   -->to mount everything inside /etc/fstab
dh -h

 
e ->to add extented partition 

RHEL7/8
df -h
lsblk
sd (SATA DISK)  == nvme (nonvolatile memory express)
nmve0n1             -->disk 1
        nvme0n1p1   -->1st partition
        nvme0n1p2
	nvme0n1p3
nmve0n2
        nvme0n2p1
        nvme0n2p1
        nvme0n2p1
ll /dev/nvme0n*   -->to list all disk and partition on the server
3 primary partition
1 extended partition (can create multiple partitions)
               logical partitions (created from extented partition)

#check available disk space
cfdisk /dev/nvme0n1
parted /dev/nvme0n1 print free

#In case there is no free space
physically add disk (in wmware settings)
*scsi
*single virtual disk 

ll /dev/nvme0n*     -->to check your new disk disks
lsblk           -->to check your new disk

If disk is nor showing, run:
yum install sg3_utils    -->allow to see newly add disk w/o rebooting the server
rescan-scsi-bus -a       -->to rescan all disks on server
lsblk                    -->to display the newly added disk
fdisk -cu /dev/nvme0n2       -->to slice the new disk
m   --to display all options (help)
p   -->print partition table
n   -->add new partition
p ->to add primary partitiion 
1  -->partition number (1st sector)
*Press Enter
*specify the size of this 1st partition
+K,M,G   (+1G)
Press Enter
p  -->to check if the partition has been created 
w  -->to save 
enter 
lsblk    -->to see the partition crearted on the new disk
partprobe /dev/nvme0n2 -->to force kernel to reread the partition table in case you don't see the partition
REBOOT the sever if you still can't see the partition

#create the file system (how data is stored and retrieve on the disk)
xfs  RHEL7/8  up to 16TB
ext4 RHEL6    up to 1TB
ext3 RHEL5

mkfs.xfs /dev/nvme0n2   -->create FS on top of the partition   (on the partiton, NOT the disk)

#create a space holder  (mount point)
mkdir /part1
mount -t xfs /dev/nvme0n2 /part1  -->to mount the partition TEMPORARY
df - h    -->to verify

#make the mount permanent
/etc/fstab
partition       mount-point  FS         option            scan order
/dev/nvme0n2	/part1	     xfs	defaults	   0 0 
                                                order of scan. only root has 1 1. 0 0 means system don't check the partition
IF YOU MAKE A MISTAKE, SERVER WILL NOT BOOT UP.

mount -a   -->to mount everything inside /etc/fstab
dh -h

######################################################
create a xfs partition of 5GB and mount it under part3

fsck -->fikle system check
umount is required bofore checking file sys on a partition

umount /part3   -->umount partition
fsck /dev/sdb1      -->check partition file system

tune2fs -c 1 /dev/sdb2  -->will run fsck after sys reboot
tune2fs -c -1 /dev/sdb2 -->no run fsck after sys reboot

II-Extended partition
/dev/sda
sda1 1.5G
sda2   1G
sda3   1G
sda4 (extended)  -->give the remaining space otherwise the remaing will not be usage

#using a LABEL to mount a partition
mkfs.xfs /dev/sda5
xfs_admin -l /dev/sda5
xfs_admin -L "label-name" /dev/sda5  -->create a label for xfs FS
xfs_admin -l /dev/sda5
mkdir /part5
vim /etc/fstab
LABEL=label-name /part6   xfs defaults  0 0 
mount -a 
df -h 

#ext4 FS
e2label /dev/sda1           -->verify
e2label /dev/sda1 <label>   -->create label for ext4 fs.
e2label /dev/sda1           -->verify 


#using UUID to mount a partition
mkfs.xfs /dev/sda6
blkid /dev/sda6   -->to get the UUID number. copy in clipboard 
mkdir /part7
vim /etc/fstab   == blkid /dev/sda6 >> /etc/fstab
UUID=xxxxxx(remove "") /part6  xfs  defaults 0 0
mount -a 
df -h

#remove a partition
1-remove/comment the entry fstab
2-umount the partition
3-remove the mount point
4-remove the partition
-----
vim /etc/fstab
remove or delete the line 
umount /part6
rm -rf part6
fdisk /dev/sda 
p
d
partition number
p
w
lsblk 

####################################################
LVM = Logical Vlume Management 
1- create a physical volume (PV)
2- create a volume group (VG)
3- create a logical volume (LV)
4- create a FS
5- createa mount point
6- entry in fstab
7- mount -a 
8- df -hT

fdisk /dev/sda
p
n
p
1
enter
+2G
L  -->change partition type from 83 (Linux) to 8e (Linux LVM)
p
w
lsblk

pvcreate /dev/sda1     -->create a physical volume
pvdisplay              -->to verify
pvs                    -->to verify
vgcreate <vgname> /dev/sda1     -->create a volume groupbnm.,
vgcreate vgtest /dev/sda1
vgdisplay              -->to verify
vgs                    -->to verify
vgs vgtest             -->display info about a specific volume group
lvcreate -L <size> -n <lvname> <vgname> 
lvcreate -L 1G -n lvtest vgtest -->create a logival volume. But make sure there is space available (vgs)
lvdisplay              -->to verify 
lvs                    -->to verify
mkfs.xfs /dev/mapper/vgtest-lvtest  -->create the FS
mkfs.xfs /dev/vgtest/lvtest         -->create the FS
mkdir /lvmount   -->create the mount point
vim /etc/fstab   -->make entry in fstab
/dev/mapper/vgtest-lvtest /lvmount  xfs   defaults  0 0
mount -a 
df -h 

lvcreate -l +100%FREE -n lvtest3 vgtest

##extend a LV
1- identify the VG used to create the LV
df -h
2- check if the VG has free space 
vgs <vgname>
3- if no space available on the VG, check the disk
cfdisk <disk>
4- if there is a free space, create a partition
5- create a PV
pvcreate <partition>  -->make sure to change partition type to 8e 
6- extend VG
vgextend <vgname> <pv>
vgextend vgtestb5 /dev/sda1
7-extend LV
lvextend -L <size> lvname
lvextend -L +2G /dev/vgtest/lvtestb5 -r  -->DONT FORGET (+) SIGN
+: extend the size
-r: extend the filesystem
lvextend -L +500M /dev/vgtest/lvtest6 -r 

original is 2G. extend the LV to 10G
-Add 10G
lvextend -L +8G -r /dev/vgtest/lvtest  
-or make total size 10G
lvextend -L 10G -r /dev/vgtest/lvtest

lvextend -l +100%FREE /dev/vgtest/lvtest -r  -->alloacate the remaining space in the VG to LV

############################################################
lvs -o +devices vgtest   -->to determine which partition was used to create a LV 
Not recommend to remove LV or VG directly from system

Homework
========
create a 5G LV and mount it using the label DBA on /dbatest
 cfdisk /dev/sda
 lsblk
 df -hT
 parted /dev/sda print free
 cfdisk /dev/sda
 fdisk /dev/sda
 partprobe /dev/sda
 lsblk
 pvcreate /dev/sda6
 vgs
 vgcreate  vgtesta6 /dev/sda6
 vgs
 lvcreate -l +100%FREE -n lvtesta6 vgtesta6
 lvs
 mkfs.xfs /dev/vgtesta6/lvtesta6
 xfs_admin -L DBA /dev/vgtesta6/lvtesta6
 mkdir /mounta6
 vim /etc/fstab
 mount -a
 df -h

##Exam question: change PE size##
use PE to create pv and vg

vgcreate -s PE vgname disk
-s:to specify PE size
vgcreate -s 8 vgrhel /dev/sda7
vgs
vgdisplay vgrhel  -->check PE size
lvcreate -l 50 -n lvrhel2 vgrhel   -->use 50 PE to create LV 
lvdisplay /dev/mapper/vgrhel-lvrhel2  -->to see PE used to create PE
vgdisplay vgrhel   -->to see remain PE

mkfs.xfs /dev/mapper/vgrhel-lvrhel2
blkid /dev/vgrhel-lvrhel2 >> /etc/fstab
mkdir /pesize
vim /dev/fstab
mount -a 
df -hT

################################################
#SCP = secure copy = copy file between linux servers 
default port = 22

echo q | telnet <remoteip> 22   -->check telnet connectivity

syntax:
scp filename remoteuser@remoteIP:/remotepath
scp file100 mory@192.168.0.41:/home/mory    -->upload a file to a remote server
scp moryba@192.168.0.40:/tmp/aclfile.txt .  -->copy/download file from a remote server
scp moryba@192.168.0.40:/tmp/aclfile.txt /var

-P: in case the default port number is changed 

Homework:
Transfer a file own by root to a remote server 
Ans:
1- cp the file to regular user home dir or to a location where 
that regular user has access to.
2- then use scp to copy the file over. 

#######################################################
swap 1 
mkswap /dev/sda1
swapon /dev/sda1
vim /etc/fstab

1- add a new swap memory (add a new partition)
 ++using standard partition
-add new didsk to server 
-change partition type to 82 (linux solaris)
fdisk /dev/sda
m
t
2
82
mkswap /dev/sda2    -->create swap file system
free -m 
swapon /dev/sda2   -->to activate the swap partition
free -m
vim /etc/fstab
/dev/sda3	swap	swap	defaults 0 0
swapon -a    -->to mount the swap memory
free -m      -->to make sure that swap size has increased 

 ++using LVM
change partition type to LVM (8e)
pvcreate /dev/sda5
pvs
vgcreate vgswap /dev/sdb2
vgs
lvcreate -l +100%FREE -n lvswap vgswap 
lvs
mkswap /dev/vgswap/lvswap
vim /etc/fstab
/dev/vgswap/lvswap	swap	swap	defaults 0 0
free -m 
swapon -a    -->to mount the swap memory
free -m 
 
2- increase/extend the existing swap memory (only if created with LVM)

#######################################################
vdo (virtual data optimizer)
rhel7.5/rhel8

=>NOT TO BE USE IN PRODUCTION ENV OR TO SAVE IMPORTANT FILE <=

/dev/sda1	/data1	5G	100G
deduplication = duplicate the same data
compression = compress the data
zero-block elimination =  

5GB is the min disk capacity

#yum install vdo and kmod-kvdo
lsmod | grep kvdo     -->check if module is loaded in the kernel 
modprobe kvdo    -->to load the module in the kernel
lsmod | grep kvdo  -->to verify
if not load in the kernel, reboot the server 
reboot -f
systemctl start vdo
systemctl enable vdo
systemctl status vdo

systemctl enable --now vdo  -->enable and start service at once 

#create the vdo 
vdo create --name=vdotest --device=/dev/sdc --vdoLogicalSize=20G  --verbose
mkfs.xfs -K /dev/mapper/vdotest
 ++FOR EXT4 FS++ FOR EXAM +++
mkfs.ext4 -E nodiscard /dev/mapper/vdotest   

mkdir /vdodir 
  ++USING FSTAB++
vim /etc/fstab
/dev/mapper/vdotest /vdodir  xfs defaults,x-systemd.requires=vdo.service  0 0
   ...Other way....
/dev/mapper/vdotest /vdodir ect4  defaults,_netdev,x-systemd.device-timeout=0,x-systemd.requires=vdo.service  0 0

 ++USING SYSTEMD++
cd /usr/share/doc/
ls           -->All man pages location
cd /usr/share/doc/vdo/examples/systemd/
ll
cp VDO.mount.example /etc/systemd/system/vdodir.mount    -->file name has to match the mount point

/etc/systemd/system    -->location for all customized services 

find / -iname "VDO.mount"   -->to easily find the path 

vim /etc/systemd/system/vdodir.mount 
  ..change only 2 things...
What =/dev/mapper/vdotest   -->vdo name 
Where = /vdodir             -->the mountpoit 

systemctl enable --now vdodir.mount
systemct status vdodir.mount 
df -h  -->check status   


mount -a 
mount -t xfs 

dd if=/dev/urandom of=largefile bs=1M count=1000  -->create a 1G file in home directory 
bs: block size 

df -h /vdodir
cp largefile /vdodir/1
df -h /vdodir
cp largefile /vdodir/2
df -h /vdodir
vdostats --human-readable     -->get the actual size you are using
cp largefile /vdodir/3
vdostats --human-readable
cp largefile /vdodir/4
vdostats --human-readable   -->notice more space saving 


vdo list     -->list all vdo
vdo printConfigFile  -->more info abt the vdo

#######################################################
SAMBA (file server) - SharePoint
Allows file sharing between windows and Linux
Accessible from the internet

 ++Share Windows Data++
create new user on win machine
create a folder under C drive 
share folder with everyone 
give read-write permission

yum install samba-client cifs-utils 
mkdir /sharepoint
smbclient -L 192.168.0.8 -U larson -->check for available share that can be mounted 
   enter pwd for larson when prompted 
mount -t cifs //serverIP/sharename /sharepoint -o username=larson,password=test123
df -h   -->to confirm that it's mounted 
  
 ++FSTAB entry++
vim /etc/fstab
//192.168.0.8/SambaShare  /sharepoint	cifs   defaults,_netdev,credentials=/root/samba  0 0

vim /root/samba
	username=larson
	password=test123
ll /root/samba
chmod 400 /root/samba  -->secure the file
mount -a 
df -h


NFS (Network File System) - SharePoint
Share file between linux machines
NB:NFS server needed. Not accessible from the internet

	INSTALL NFS SERVER 
- yum install nfs*
- lsmod | grep nfsd (if not loaded run the next cmd)
- modprobe nfsd
- chkconfig rpcbind on
- chkconfig nfslock on
- chkconfig nfs on
- vim /etc/sysconfig/nfs  (uncomment the lines below)
	RQUOTAD_PORT=875
	LOCKD_TCPPORT=32803
	LOCKD_UDPPORT=32769
	MOUNTD_PORT=892
	STATD_PORT=662
	STATD_OUTGOING_PORT=2020
	RPCNFSDARGS="-N 2 -N 3"  (to turn off version 2 and 3)
###optional###
- open ports tcp 32803
- open ports udp 32769
- open ports tcp/udp 875
- open ports tcp/udp 662
- open ports tcp/udp 2020

###optional###
- open ports tcp/udp 892
- open ports tcp/udp 111
- open ports tcp 2049
- service iptables save; service iptables restart
- setsebool -P nfs_export_all_ro on
- setsebool -P nfs_export_all_rw on   -->last 2 steps not required if SELINUX is disable 
- mkdir /share
- vim /etc/exports
	/share *(rw,no_root_squash) or
	/share 192.168.1.0(rw,ro_root_squash) or
	/share client1(rw,ro_root_squash) or
- exportfs -avr
- service rpcbinf restart
- service nfslock restart 
- service nfs restart 
- showmount -e 192.168.1.2 (serverip)  (to verify that is working)

NFS CLIENT
- yum install nfs-utils
- systemctl enable rpcbind  
- showmount -e nfsserverip    -->list everything that can be mounted
- mkdir /nfs_share  -->create the mount point
 ++temporary mount it++
mount -t cifs 192.168.1.31:/home  /nfs_share/ 
df -h

 ++permanently mount it++
vim /etc/fstab
192.168.0.31:/home  nfs_share   nfs 	defaults,_netdev,nfsvers=3  0 0 
mount -a
df -h 

########################################################
autofs  1 325 rhel7

mount a FS on 
FREE IPA  <--->ldap replacement
autofs -->mount file on demand 

exportfs -avr  -->to check nfs share on the server 

yum install nfs-utils autofs -y  -->will install auto.master and auto.misc
ll /etc/auto*
    auto.master    -->location of the mount point
    auto.misc
vim /etc/auto.master
        /misc   /etc/auto.misc    -->write under this entry in order to follow the syntax
	/backup /etc/auto.backup
vim /etc/auto.backup
mount the entire directory under server home dir.
	*   -fstype=nfs,nfsvers=3,rw,soft,intr  192.168.1.31:/home/&
or mount each individual directory under home directory , 
        guest  -fstype=nfs,nfsvers=3,rw,soft,intr  192.168.1.31:/home/
systemctl enable --now autofs
systemctl restart autofs
cd /home/backup
ll
df -h 
NB: you can move between users under the server home directory  

	
	INSTALL A SAMBA SERVER 
yum install *samba
systemctl enable --now smb
systemctl enable --now nmb
firewall-cmd --permanent --add-service=samba
firewall-cmd --permanent --add-service=samba
firewall-cmd --permanent --add-port=137/udp
firewall-cmd --permanent --add-port=138/udp
firewall-cmd --permanent --add-port=139/tcp
firewall-cmd --permanent --add-port=187/udp
firewall-cmd --permanent --add-port=445/tcp
firewall-cmd --reload 
mkdir /sambashare
semanage fcontent -a -t samba_share_t "/sambashare(/.*)?"
restorecon -rv /sambashare/*
touch /sambashare/file
setsebool -P samba_export_all_ro on
setsebool -P samba_export_all_rw on
vim /etc/samba/smb.conf
++[global]++
   passdb blackend = smbpasswd
   netbios name = class7
++[print$]++
[sambashare]

testparm 
useradd -s /sbin/nologin user1
passwd user1
smbpasswd -a user1
pdbedit -L
cat /var/lib/samba/private/smbpasswd
systemctl restart smb nmb winbind

	FOR SAMBA CLIENT do the following
server: 198.50.221.241  (user IP @ instead hostname)
user: user1
passwd: redhat
mount point: /samba

dig -x  198.50.221.241
smbclient -L 198.50.221.241 -U user1
firewall-cmd --list-all

##########################################################
containers 1-2 
container are packages of software that contain all of the necessary elements
to run in any environment. In this way, containers virtualize the OS and run 
anywhere, from a private data center to the public cloud or even on a developer's
personal laptop.

kubernetes -->orchestration tools. deploy more containers at the same time '
OpenShift -->rhedhat containers (kuberneters + redhat support)
Docker -->tool used to deploy container 
 #yum intstall docker
 #systemctl enable --now docker
 #docker ps -a -->to check all running containers  
podman -->redhat tool to deplay container 
 #podman ps -a 

while true; do ssh moryba@192.168.0.40; sleep 5; done 

yum update -y
yum module install container-tools 
or, yum install podman-docker     -->in case container-tools installation fails
vim /etc/containers/registries.conf -->registry config file
podman search redhat

#naming convention
registry.redhat.io/redhat7.2:tag latest
registry -compay -image_name -tag 
   
podman pull registry.access.redhat.com/rhel7.4   -->to download an image from the repository to your VM or laptop. May require you to have an account 
podman pull docker.io/redhat/ubi8 -->docker doesn't require an account 
podman images -->to list all images for that specific user.

#run a container live
podman run -it --name=<name> <image> <command>
i: interact with the container
t: tty - provide a terminal for that container
podman run -it name=test docker.io/redhat/ubi8 ls -->deploy this container and run this command (ls)
podman ps   -->no running container
podman ps -a  -->list all running and stopped containers

#run a container in the background
podman run -d -it --name=<name> <image> <command>
d:run it as a deamon (in the bg)
podman run -d -it --name=test1 docker.io/redhat/ubi8 /bin/bash
-different name but same container

#run a container 
podman exec --it test1 /bin/bash

#list all running containers 
podman ps

#stop a container
podman stop test1

#start a container
podman start test

#stop all running containers
podman stop -a 

#remove stopped container
podman rm test
podman rm -a -->remove all stopped containers 
NB: stop container before removing it 

#remove image 
podman images    --grab image ID
podman rmi 343496049fae

Achage web server as a contaier
podman search apacher
podman pull docker.io/library/httpd   -->download the image 
podman run -d -it name=httpserver -p 8080=80 docker.io/ubuntu/apache2  /bin/bash
-p:mapper 8080:80
8080- for your local machine
80- for the container 
 
#exam question
Map a partition from your local machine to a specific folder in the container?  

mkdir /test
podman run -d -it --name=httpserver2 -p 8080:80 -v /test:/var/www/html:Z docker.io/library/httpd /bin/bash 
-Z:to setup SELINUX container_file_t context 
-v:volume. Mount a volume from local machine to /var/www/html in the container 
or, #podman run --privileged -d -it --name=httpserver2 -p 8080:80 -v /test:/var/www/html docker.io/library/httpd /bin/bash
#Anything inside /test will also be inside /var/www/html
podman ps   -->verify
vim /test/index.html   -->create a file under /test
#will be created under /var/www/ in the container
podman exec -it webserver2 /bin/bash   -->to verify file creration
pwd
cd /var/www/html
ll          -->see that the file index.html has been created 
exit -->to exit the container
podman ps -->still running


run a podman as a service (as a regular user)
useradd user1
passwd user1
or, #echo "123456" | passwd user1 --stdin
#Make sure that user1 logs in at least one in the server 
wile ture; do ssh user1@192.168.0.40: sleep 5; done
ll -a
should be able to see default files and directory in a user home directory

#as root user
loginctl show-user user1   -->check if user can run an app as a service 
#look for the last line 
 Linger=no 
no:user can't run app
#change to it
loginctl enable-linger user1
loginctl show-user user1  -->to confirm that it's enable
 Linger=yes 
getsebool -a  | grep container 
 container_manage_cgroup
setsebool -P container_manage_cgroup on
P:to make it permanent
getsebool -a | grep container -->to ensure that it's ON

#the user can now a container
#as reguarlar user (user1)
podman ps -a   -->no container present
podman run -d -it --name=httpserveruser1 -p 8081:80 -v /test:/var/www/html:Z docker.io/apache/fineract /bin/bash
8081: cs port 8080 is already been used. 
NB:In case selinux doesn't work /test. run selinux manually:
	semanage fcontext -a -t container_file_t "/test(/.*)?"
	restorecon -rv /test 
podman ps   -->to make sure that container is running
mkdir -p .config/systemd/user
cd .config/systemd/user
podman generate systemd --name httpserveruser1 --files -->generate a systemd file
ll
vim container-httpserveruser1.service 
podman stop httpserveruser1   -->stop the container in order to run it as a servcie 
systemctl --user daemon-reload 
systemctl --user enable --now container-httpserveruser1.service 
systemctl --user status container-httpserveruser1.service 
 

*create /svr/web directory, and extract the content of https://training.linuxtechnologies.us/test/web-content.tar.gz in that 
directory so that rootless container can use it for persistent storage 
*As daniel user, create a detached HTTP Server container named web. user the registry,.access.redhat.com/ubi8/php-74 from 
registry. Map port 8080 in the container to port 8888 on the host. Mount the srv/web directory on the host as /var/www/html 
in the container.
*As the user daniel, configure systemd so that the web container starts automatically with the server.

mkdir -p /svr/web
cd /svr/web                  -->may need to do yum install wget
wget https://training.linuxtechnologies.us/test/web-content.tar.gz
ll
tar xvfz web.content.tar.gz

or,
man wget   -->to see how to send it directly to the folder

wget https://training.linuxtechnologies.us/test/web-content.tar.gz  -o /svr/web


 